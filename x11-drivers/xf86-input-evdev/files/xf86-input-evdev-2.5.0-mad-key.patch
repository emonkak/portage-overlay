From cfccfac936d4b9630b2e1cab2cfed05d1c9c8db1 Mon Sep 17 00:00:00 2001
From: emonkak <emonkak@gmail.com>
Date: Tue, 21 Dec 2010 23:44:18 +0900
Subject: [PATCH] xf86-input-evdev-2.5.0-mad-key

---
 src/evdev.c |  185 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++--
 src/evdev.h |   30 ++++++++++
 2 files changed, 209 insertions(+), 6 deletions(-)

diff --git a/src/evdev.c b/src/evdev.c
index 512e957..aeb7b99 100644
--- a/src/evdev.c
+++ b/src/evdev.c
@@ -115,6 +115,32 @@ static Atom prop_btn_label = 0;
  * cannot be used by evdev, leaving us with a space of 2 at the end. */
 static EvdevPtr evdev_devices[MAXDEVICES] = {NULL};
 
+static void AddMadKey(EvdevPtr pEvdev, int trigger, int transfer, MadKeyType type)
+{
+    MadKeyList *keyList = pEvdev->madKeyList;
+    MadKeyList *key;
+    if (keyList != NULL) {
+        while (keyList->next != NULL)
+            keyList = keyList->next;
+    }
+
+
+    key = xcalloc(sizeof(MadKeyList), 1);
+    if (key == NULL)
+        return;
+
+    key->madKey = &key->madKeyEntity;
+    key->madKey->trigger = trigger;
+    key->madKey->transfer = transfer;
+    key->madKey->type = type;
+    key->next = NULL;
+
+    if (keyList == NULL)
+        pEvdev->madKeyList = key;
+    else
+        keyList->next = key;
+}
+
 static int EvdevSwitchMode(ClientPtr client, DeviceIntPtr device, int mode)
 {
     InputInfoPtr pInfo;
@@ -262,13 +288,26 @@ static int wheel_down_button = 5;
 static int wheel_left_button = 6;
 static int wheel_right_button = 7;
 
+static void
+EvdevEnqueKeyEvent(EvdevPtr pEvdev, int code, int value)
+{
+    EventQueuePtr pQueue = &pEvdev->queue[pEvdev->num_queue];
+    pQueue->type = EV_QUEUE_KEY;
+    pQueue->key = code + MIN_KEYCODE;
+    pQueue->val = value;
+    pEvdev->num_queue++;
+}
+
 void
 EvdevQueueKbdEvent(InputInfoPtr pInfo, struct input_event *ev, int value)
 {
     int code = ev->code + MIN_KEYCODE;
-    EventQueuePtr pQueue;
     EvdevPtr pEvdev = pInfo->private;
 
+    int scanCode = ev->code;
+    unsigned int tmpScanCode = scanCode;
+    unsigned int lastScanCode = pEvdev->lastScanCode;
+
     /* Filter all repeated events from device.
        We'll do softrepeat in the server, but only since 1.6 */
     if (value == 2
@@ -289,11 +328,87 @@ EvdevQueueKbdEvent(InputInfoPtr pInfo, struct input_event *ev, int value)
         return;
     }
 
-    pQueue = &pEvdev->queue[pEvdev->num_queue];
-    pQueue->type = EV_QUEUE_KEY;
-    pQueue->key = code;
-    pQueue->val = value;
-    pEvdev->num_queue++;
+  /*
+   * Sticky Key
+   */
+  if (value) {
+      if (pEvdev->stickyPhase == 1) {
+          pEvdev->stickyPhase = 2;
+          EvdevEnqueKeyEvent(pEvdev, pEvdev->stickyScanCode, TRUE);
+          goto madKeyFinish;
+      } else if (pEvdev->stickyPhase == 2) {
+          pEvdev->stickyPhase = 0;
+          EvdevEnqueKeyEvent(pEvdev, pEvdev->stickyScanCode, FALSE);
+          goto madKeyFinish;
+      }
+  } else {
+      MadKeyList *keyList;
+      for (keyList = pEvdev->madKeyList; keyList != NULL; keyList = keyList->next) {
+          MadKey *key = keyList->madKey;
+          if (key->type == MAD_KEY_STICKY
+              && key->trigger == scanCode
+              && lastScanCode == scanCode) {
+              if (pEvdev->stickyPhase == -1) { /* ignore */
+                  pEvdev->stickyPhase = 0;
+                  break;
+              } else {
+                  pEvdev->stickyPhase = 1;
+                  pEvdev->stickyScanCode = keyList->madKey->transfer;
+                  return;
+              }
+          }
+      }
+  }
+
+  /*
+   * Pseudo Modifier
+   */
+  {
+      MadKeyList *keyList;
+      for (keyList = pEvdev->madKeyList; keyList != NULL; keyList = keyList->next) {
+          MadKey *key = keyList->madKey;
+          if (key->type == MAD_KEY_PSEUDO_MOD
+              && key->trigger == scanCode) {
+              if (lastScanCode == key->transfer) {
+                  tmpScanCode = lastScanCode;
+                  pEvdev->stickyPhase = -1;
+              } else if (value)
+                  scanCode = key->transfer;
+              else {
+                  if (lastScanCode == scanCode) {
+                      EvdevEnqueKeyEvent(pEvdev, key->transfer, FALSE);
+                      EvdevEnqueKeyEvent(pEvdev, key->trigger, TRUE);
+                  } else
+                      scanCode = key->transfer;
+              }
+              goto madKeyFinish;
+          }
+      }
+  }
+
+  /*
+   * One Shot Modifier
+   */
+  if (!value) {
+      MadKeyList *keyList;
+      for (keyList = pEvdev->madKeyList; keyList != NULL; keyList = keyList->next) {
+          MadKey *key = keyList->madKey;
+          if (key->type == MAD_KEY_ONE_SHOT_MOD
+              && key->trigger == scanCode
+              && lastScanCode == scanCode) {
+              scanCode = key->transfer;
+              EvdevEnqueKeyEvent(pEvdev, lastScanCode, FALSE);
+              EvdevEnqueKeyEvent(pEvdev, scanCode, TRUE);
+              goto madKeyFinish;
+          }
+      }
+  }
+
+madKeyFinish:
+  if (value)
+      pEvdev->lastScanCode = tmpScanCode;
+
+  EvdevEnqueKeyEvent(pEvdev, scanCode, value);
 }
 
 void
@@ -1101,6 +1216,9 @@ EvdevAddKeyClass(DeviceIntPtr device)
     pInfo = device->public.devicePrivate;
     pEvdev = pInfo->private;
 
+    pEvdev->lastScanCode = 0;
+    pEvdev->stickyPhase = 0;
+
     /* sorry, no rules change allowed for you */
     xf86ReplaceStrOption(pInfo->options, "xkb_rules", "evdev");
     SetXkbOption(pInfo, "xkb_rules", &pEvdev->rmlvo.rules);
@@ -2126,6 +2244,61 @@ EvdevPreInit(InputDriverPtr drv, IDevPtr dev, int flags)
         EvdevDragLockPreInit(pInfo);
     }
 
+    if (pEvdev->flags & EVDEV_KEYBOARD_EVENTS)
+    {
+        pEvdev->madKeyList = NULL;
+        if (xf86FindOption(pInfo->options, "StickyShift")) {
+            AddMadKey(pEvdev, KEY_LEFTSHIFT, KEY_LEFTSHIFT, MAD_KEY_STICKY);
+            AddMadKey(pEvdev, KEY_RIGHTSHIFT, KEY_RIGHTSHIFT, MAD_KEY_STICKY);
+            xf86Msg(X_CONFIG, "%s: StickyShift enabled\n", pInfo->name);
+        }
+        if (xf86FindOption(pInfo->options, "StickyCtrl")) {
+            AddMadKey(pEvdev, KEY_LEFTCTRL, KEY_LEFTCTRL, MAD_KEY_STICKY);
+            AddMadKey(pEvdev, KEY_RIGHTCTRL, KEY_RIGHTCTRL, MAD_KEY_STICKY);
+            xf86Msg(X_CONFIG, "%s: StickyCtrl enabled\n", pInfo->name);
+        }
+        if (xf86FindOption(pInfo->options, "StickyAlt")) {
+            AddMadKey(pEvdev, KEY_LEFTALT, KEY_LEFTALT, MAD_KEY_STICKY);
+            AddMadKey(pEvdev, KEY_RIGHTALT, KEY_RIGHTALT, MAD_KEY_STICKY);
+            xf86Msg(X_CONFIG, "%s: StickyAlt enabled\n", pInfo->name);
+        }
+        if (xf86FindOption(pInfo->options, "PseudoModSpace")) {
+            int transfer = xf86SetIntOption(pInfo->options,
+                                            "PseudoModSpace",
+                                            MIN_KEYCODE) - MIN_KEYCODE;
+            AddMadKey(pEvdev, KEY_SPACE, transfer, MAD_KEY_PSEUDO_MOD);
+            xf86Msg(X_CONFIG, "%s: PseudoModSpace enabled\n", pInfo->name);
+        }
+        if (xf86FindOption(pInfo->options, "OneShotShift")) {
+            int transfer = xf86SetIntOption(pInfo->options,
+                                            "OneShotShift",
+                                            MIN_KEYCODE) - MIN_KEYCODE;
+            AddMadKey(pEvdev, KEY_LEFTSHIFT, transfer, MAD_KEY_ONE_SHOT_MOD);
+            AddMadKey(pEvdev, KEY_RIGHTSHIFT, transfer, MAD_KEY_ONE_SHOT_MOD);
+            xf86Msg(X_CONFIG, "%s: OneShotShift enabled\n", pInfo->name);
+        }
+        if (xf86FindOption(pInfo->options, "OneShotCtrl")) {
+            int transfer = xf86SetIntOption(pInfo->options,
+                                            "OneShotCtrl",
+                                            MIN_KEYCODE) - MIN_KEYCODE;
+            AddMadKey(pEvdev, KEY_LEFTCTRL, transfer, MAD_KEY_ONE_SHOT_MOD);
+            AddMadKey(pEvdev, KEY_RIGHTCTRL, transfer, MAD_KEY_ONE_SHOT_MOD);
+#ifdef XKB
+            if (xkb_options != NULL && strstr(xkb_options, "ctrl:swapcaps") != NULL)
+                AddMadKey(pEvdev, KEY_CAPSLOCK, transfer, MAD_KEY_ONE_SHOT_MOD);
+#endif
+            xf86Msg(X_CONFIG, "%s: OneShotCtrl enabled\n", pInfo->name);
+        }
+        if (xf86FindOption(pInfo->options, "OneShotAlt")) {
+            int transfer = xf86SetIntOption(pInfo->options,
+                                            "OneShotAlt",
+                                            MIN_KEYCODE) - MIN_KEYCODE;
+            AddMadKey(pEvdev, KEY_LEFTALT, transfer, MAD_KEY_ONE_SHOT_MOD);
+            AddMadKey(pEvdev, KEY_RIGHTALT, transfer, MAD_KEY_ONE_SHOT_MOD);
+            xf86Msg(X_CONFIG, "%s: OneShotAlt enabled\n", pInfo->name);
+        }
+    }
+
     return pInfo;
 
 error:
diff --git a/src/evdev.h b/src/evdev.h
index 4945140..1e67e44 100644
--- a/src/evdev.h
+++ b/src/evdev.h
@@ -104,6 +104,25 @@ typedef struct {
     int traveled_distance;
 } WheelAxis, *WheelAxisPtr;
 
+/* key status data for mad-key system  */
+typedef enum {
+    MAD_KEY_STICKY,
+    MAD_KEY_PSEUDO_MOD,
+    MAD_KEY_ONE_SHOT_MOD,
+} MadKeyType;
+
+typedef struct {
+    int        trigger;
+    int        transfer;
+    MadKeyType type;
+} MadKey;
+
+typedef struct MadKeyList {
+    MadKey             madKeyEntity;
+    MadKey            *madKey;
+    struct MadKeyList *next;
+} MadKeyList;
+
 /* Event queue used to defer keyboard/button events until EV_SYN time. */
 typedef struct {
     enum {
@@ -133,6 +152,17 @@ typedef struct {
     int delta[REL_CNT];
     unsigned int abs, rel;
 
+    int                 lastScanCode;
+    int                 stickyScanCode;
+    /*
+     * -1: ignore
+     *  0: disabled
+     *  1: presss enabled
+     *  2: release enabled
+     */
+    int                 stickyPhase;
+    MadKeyList          *madKeyList;
+
     /* XKB stuff has to be per-device rather than per-driver */
 #if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 5
     XkbComponentNamesRec    xkbnames;
-- 
1.7.3.4

